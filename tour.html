<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>tour</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Java build tool">
    <meta name="author" content="Jerome Angibaud">
    <meta name="keywords" content="build,java,tool,automation,maven,ant,gradle,buildr,sbt,make,compiler,tester,jacoco">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="css/bootstrap.css" rel="stylesheet">
    <!-- <link href="css/bootstrap.min.css" rel="stylesheet">  -->
    <link href="css/asciidoctor.css" rel="stylesheet">
    <link href="css/base.css" rel="stylesheet">
    <link href="css/prettify.css" rel="stylesheet">
    <link href="css/jerkar.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
      
    <![endif]-->
    
      <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="favicon.ico">
  
  	<!-- highlight.js -->
  	<script src="js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<link rel="stylesheet" href="css/highlight-idea.css">
	
	<!-- sidebar css -->
	<link href="css/sidebar.css" rel="stylesheet">
  
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand">
          	<img style="max-width:32px;margin-top: -7px;" src="img/logo.png">
          </a>
          <a class="navbar-brand">Jerkar</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="index.html">Home</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation<b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="documentation/latest/getting-started.html">Tutorial</a></li>
                <li><a href="documentation/latest/reference.html">Reference Guide</a></li>
                <li><a href="javadoc/latest/index.html">Javadoc</a></li>
              </ul>
            </li>
            <li><a href="about.html">About</a></li>
          </ul>
        </div>
       
        
      </div>
    </div>
    <div class="container">
	<p>
	<div id="sidebar-menu" class="col-md-3 hidden-xs hidden-sm">
    <ul class="main-menu nav nav-stacked affix">
        <li><a href="javascript:jerkarMoveTo('Principles',2);">Principles</a></li>
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Build styles',2);">Build styles</a>
          <ul class="sub-menu">
            <li><a href="javascript:jerkarMoveTo('Task based builds (ala Ant)',3);">Task based builds (ala Ant)</a></li>
            <li><a href="javascript:jerkarMoveTo('Templated builds (ala Maven)',3);">Templated builds (ala Maven)</a></li>
            <li><a href="javascript:jerkarMoveTo('Templated builds with conventions',3);">Templated builds with conventions</a></li>
            <li><a href="javascript:jerkarMoveTo('Fully conventional style !!!',3);">Fully conventional style !!!</a></li>
            <li><a href="javascript:jerkarMoveTo('Eclipse style',3);">Eclipse style</a></li>
            <li><a href="javascript:jerkarMoveTo('Custom builds with third parties',3);">Custom builds with third parties</a></li>
            <li><a href="javascript:jerkarMoveTo('Multi-project builds',3);">Multi-project builds</a></li>
          </ul>
        </li>
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Out-of-the-box features',2);">Out-of-the-box features</a>
          <ul class="sub-menu">
            <li><a href="javascript:jerkarMoveTo('Basic tasks',3);">Basic tasks</a></li>
            <li><a href="javascript:jerkarMoveTo('Plugin tasks',3);">Plugin tasks</a></li>
            <li><a href="javascript:jerkarMoveTo('Examples',3);">Examples</a></li>
          </ul>
        </li>
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Build API',2);">Build API</a>
          <ul class="sub-menu">
            <li><a href="javascript:jerkarMoveTo('File manipulation & selection',3);">File manipulation & selection</a></li>
            <li><a href="javascript:jerkarMoveTo('Process launching',3);">Process launching</a></li>
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Java core stuffs',3);">Java core stuffs</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Classpaths',4);">Classpaths</a></li>
                <li><a href="javascript:jerkarMoveTo('Class loarders',4);">Class loarders</a></li>
                <li><a href="javascript:jerkarMoveTo('Lauching Java programs',4);">Lauching Java programs</a></li>
              </ul>
            </li>
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Java build API',3);">Java build API</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Compile Java',4);">Compile Java</a></li>
                <li><a href="javascript:jerkarMoveTo('Junit',4);">Junit</a></li>
              </ul>
            </li>
            <li><a href="javascript:jerkarMoveTo('Dependency Management',3);">Dependency Management</a></li>
            <li><a href="javascript:jerkarMoveTo('Publication ',3);">Publication </a></li>
            <li><a href="javascript:jerkarMoveTo('Cryptography',3);">Cryptography</a></li>
            <li><a href="javascript:jerkarMoveTo('SonarQube',3);">SonarQube</a></li>
          </ul>
        </li>
    </ul>
</div>
<script>
function jerkarMoveTo(title, level) {
    var elemType = 'h'+level;
    var elems = $(elemType);
    var elem;
    for (var i = 0; i < elems.length; i++) {
    	var candidate = elems[i];
    	if (candidate.outerText ===  title) {
    		elem = candidate;
    		break;
    	}
    }
    $('html, body').animate({
        scrollTop: $(elem).offset().top -50
    }, 200);
}
</script><p><div id="static-content" class="col-md-9"></p><h1>Enjoy the Jerkar tour !</h1>
<hr/><p>This page will give you a concrete idea on how Jerkar is working and what you can do with.</p><h2>Principles</h2><p>Jerkar is quite simpe in its principle. You write a class extending <code>org.jerkar.tool.JkBuild</code> in the <em>build/def</em> folder of your project then you can execute any public zero arg methods from the command line by executing <code>jerkar myMethod1 myOtherMethod</code> at the root folder of your project. To accomplish this, Jerkar :</p>
<ul>
  <li>compiles every java sources found under the <em>build/def</em> folder</li>
  <li>instantiates the first compiled class found implementing <code>org.jerkar.tool.JkBuild</code>. If none the <code>org.jerkar.tool.builtins.templates.javabuild.JkJavaBuild</code> class is instantiated</li>
  <li>invokes specified methods on the created instance. If no method is specified then the <code>doDefault</code> method is invoked</li>
</ul><p>You can also set instance field from the command line by typing <code>jerkar myMethod -myField=foo</code>.<br/><br/></p><h2>Build styles</h2><p>With Jerkar you can write task based build definition (ala <em>Ant</em>), templated ones (ala <em>Maven</em>) or rely on conventions only (no build script needed). In the following section, we will illustrate different different approach to use Jerkar. </p><h3>Task based builds (ala Ant)</h3><p>If you like to have complete control over your build, you may prefere the <em>Ant</em> build style.<br/>The price is that you have to <em>write explicitly</em> what your build is doing. </p><p>This example mimics the <a href="http://ant.apache.org/manual/tutorial-HelloWorldWithAnt.html">tutorial ANT build script</a> </p>
<pre><code class="Java">public class AntStyleBuild extends JkBuild {

	@JkDoc(&quot;Run tests in forked process if true&quot;)
	boolean forkTests;
	
	String name = &quot;myProject&quot;;
	File src = baseDir(&quot;src&quot;);
	File buildDir = baseDir(&quot;build/output&quot;);
	File classDir = new File(buildDir, &quot;classes&quot;);
	File jarFile = new File(buildDir, &quot;jar/&quot; + name + &quot;.jar&quot;);
	String className = &quot;my.mainClass&quot;;
	JkClasspath classpath = JkClasspath.of(baseDir().include(&quot;libs/*.jar&quot;));
	File reportDir = new File(buildDir, &quot;junitRreport&quot;);
	
	@Override
	public void doDefault() {
		clean();jar();run();
	}
	
	public void compile() {
		JkJavaCompiler.ofOutput(classDir).withClasspath(classpath).andSourceDir(src).compile();
		JkFileTree.of(src).exclude(&quot;**/*.java&quot;).copyTo(classDir);
	}
	
	public void jar() {
		compile();
		JkManifest.empty().addMainClass(&quot;my.main.RunClass&quot;).writeToStandardLocation(classDir);
		JkZipper.of(classDir).to(jarFile);
	}	
	
	@JkDoc(&quot;Run the application&quot;)
	public void run() {
		JkJavaProcess.of(jarFile).andClasspath(classpath).runSync();
	}
	
	public void cleanBuild() {
		clean();
		junit();
	}
	
	public void junit() {
		jar();
		JkUnit.of(classpath.and(jarFile))
				.withClassesToTest(JkFileTree.of(classDir).include(&quot;**/*Test.class&quot;))
				.withReportDir(reportDir)
				.withReport(JunitReportDetail.FULL)
				.forked(forkTests)
				.run();
	}
	
	public static void main(String[] args) {
		new AntStyleBuild().doDefault();
	}
	
}
</code></pre><p>From this build definition, we can execute Jerkar the following way :</p>
<ul>
  <li>launch/debug the <code>AntStyleBuild main</code> within your IDE</li>
  <li>launch/debug the <code>org.jerkar.JkMain main</code> method within your IDE. In this mode you can pass arguments as you would for the command line</li>
  <li>execute a command line in a shell (or on a build server) as <code>jerkar doDefault</code> or <code>jerkar cleanBuild -forkTests=true</code>.</li>
</ul><p><br/></p><h3>Templated builds (ala Maven)</h3><p>For Java project you may directly extend <code>JkJavaBuild</code> template class which implements common methods for you.<br/>All you need is to implement what is specific.</p>
<pre><code>public class MavenStyleBuild extends JkJavaBuild {
	
	@Override  // optional
	public JkModuleId moduleId() {
		return JkModuleId.of(&quot;org.jerkar&quot;, &quot;script-samples&quot;);
	}

	@Override  // optional
	protected JkVersion version() {
		return JkVersion.ofName(&quot;0.3-SNAPSHOT&quot;);
	}

	@Override
	// Optional : needless if you use only local dependencies
	protected JkDependencies dependencies() {
		return JkDependencies
				.builder()
				.on(GUAVA, &quot;18.0&quot;)  // Popular modules are available as Java constant
				.on(JERSEY_SERVER, &quot;1.19&quot;)
				.on(&quot;com.orientechnologies:orientdb-client:2.0.8&quot;)
				.on(JUNIT, &quot;4.11&quot;).scope(TEST).on(MOCKITO_ALL, &quot;1.9.5&quot;)
				.scope(TEST).build();
	}

}
</code></pre><p>This example is for demo purpose. Some settings can be omitted by respecting naming conventions...<br/><br/></p><h3>Templated builds with conventions</h3><p>If you follow conventions (as project folder named as <em>groupName.projectName</em> and version stored in a <em>version.txt</em> file), the above script turns to :</p>
<pre><code>public class BuildSampleClassic extends JkJavaBuild {
	
	@Override  // Optional :  needless if you use only local dependencies
	protected JkDependencies dependencies() {
		return JkDependencies.builder() 
			.on(GUAVA, &quot;18.0&quot;)  
			.on(JERSEY_SERVER, &quot;1.19&quot;)
			.on(&quot;com.orientechnologies:orientdb-client:2.0.8&quot;)
			.on(JUNIT, &quot;4.11&quot;).scope(TEST)
			.on(MOCKITO_ALL, &quot;1.9.5&quot;).scope(TEST)
		.build();
	}	
}
</code></pre><h3><a name="100conventional"></a><br/>Fully conventional style !!!</h3><p>If you use only local dependencies (jar dependencies located as bellow), you don't even need to write a build file.<br/>Note that local dependencies have to be located in subfolder corresponding to its scope (build, compile, runtime,...).</p><p><img src="img/full-convention-project.png" alt="Project layout full convention""/></p><h3>Eclipse style</h3><p>If Eclipse is your IDE, you can just reuse information from the <em>.classpath</em> file by using the Eclipse plugin.<br/>Project name, source folders and dependencies can be deducted from this file. Just activate the Eclipse plugin (see below).</p><h3>Custom builds with third parties</h3><p>Your build class can depend itself from managed dependencies </p>
<pre><code>@JkImport(&quot;org.seleniumhq.selenium:selenium-java:2.45.0&quot;)
public class SeleniumTaskBuild extends JkJavaBuild {
	
	@JkDoc(&quot;Performs some load test using Selenium&quot;)
	public void seleniumLoadTest() {
		WebDriver driver = new FirefoxDriver();
		// ....
	}
}
</code></pre><h3>Multi-project builds</h3><p>In a multi project context, build instances, from different projects, can use each other.<br/>In general, the build dependency schema is the same than for the code.</p>
<pre><code>// This is the master project for building the Jerkar full distribution
public class DistribAllBuild extends JkBuildDependencySupport {
	
	@JkProject(&quot;../org.jerkar.plugins-sonar&quot;)
	PluginsSonarBuild pluginsSonar;
	
	@JkProject(&quot;../org.jerkar.plugins-jacoco&quot;)
	PluginsJacocoBuild pluginsJacoco;
	
	public void doDefault() {
		super.doDefault();
		multiProjectDependencies().invokeDoDefaultMethodOnAllSubProjects();
		CoreBuild core = pluginsJacoco.core;  // The core project is got by transitivity
		
		JkFileTree sourceDir = ...;
		sourceDir.importFiles(pluginsSonar.packer().jarSourceFile(), pluginsJacoco.packer().jarSourceFile());
		...
	} 
	
	
}
</code></pre>
<div class="alert alert-info" role="alert">
<strong>Note that you can reuse external build elements in a statically typed way !!! </strong>
</div><h2>Out-of-the-box features</h2><p>This section answer to the following question : <blockquote>What Jerkar can do for me if I haven't written build file or have just a build file declaring dependencies only ?</blockquote></p><p>Yep, with Jerkar, if you don't have written any build file or just have a build file containing dependency definition, you can yet perform pretty sophisticated tasks. </p><h3>Basic tasks</h3>
<ul>
  <li><code>jerkar help</code> : outputs on console available methods and options for Jerkar in the current project.</li>
  <li><code>jerkar clean</code> : clean the output directory that is <em>[project dir]/build/output</em>.</li>
  <li><code>jerkar compile</code> : compile the production code (not the test code) and put resources in <em>[project dir]/build/classes</em> directory.</li>
  <li><code>jerkar unitTest</code> : compile the unit tests and run it.</li>
  <li><code>jerkar pack</code> : creates jars from the compiled sources and processed resources (creates test, sources and fat jar as well).</li>
  <li><code>jerkar verify</code> : launch code quality tools on the sources : by default this does not do anyhing unless you activate some quality control plugin (see below).</li>
  <li><code>jerkar publish</code> : publish the produced artifact in the remote repository.</li>
</ul><p>Beside convenient methods are available to launch a 'life-cycle' sequence :</p>
<ul>
  <li><code>jerkar doCompile</code> = <code>jerkar clean compile</code>.</li>
  <li><code>jerkar doUnitTest</code> = <code>jerkar doCompile uniTest</code>.</li>
  <li><code>jerkar doPack</code> = <code>jerkar doUnitTest pack</code>.</li>
  <li><code>jerkar doVerify</code> = <code>jerkar doPack verify</code>.</li>
  <li><code>jerkar doPublish</code> = <code>jerkar doVerify publish</code>.</li>
</ul><p>Whitout omitting the shorthands :</p>
<ul>
  <li><code>jerkar</code> = <code>jerkar doDefault</code> = <code>jerkar doPack</code></li>
</ul><p>These taskscan be parametrized :</p>
<ul>
  <li><code>jerkar -fatJar=true -forkTests=true</code> = <code>jerkar doPack</code> + forking the unit tests and produce a fat jar</li>
</ul><p>The last will result in the following artifact creation :<br/><img src="img/output.png" alt="Created artifacts""/></p><h3>Plugin tasks</h3><p>Template classes (<code>JkBuild</code> and <code>JkJavaBuild</code>) enable plugability by providing hooks on several methods.<br/>A plugin is just a class extending <code>JkBuildPlugin</code> or <code>JkJavaBuildPlugin</code> and overriding default hook methods. Plugins can also provide their own methods.</p>
<ul>
  <li>To activate a plugin on the command line, just mention the name of the plugin followed by a <code>#</code>.</li>
  <li>To parameter a plugin, just mention <code>-pluginName#fieldName=value</code>.</li>
  <li>To launch a method of a plugin, just mention <code>-pluginName#methodName</code>, note that the plugin does not need to be activated for invoking a plugin method.</li>
  <li>To display information about available plugins in current Jerkar instance, simply execute <code>jerkar helpPlugins</code>.</li>
</ul><h3>Examples</h3><p>Jerkar is shipped with <a href="http://eclipse.org/">Eclipse</a>, <a href="http://www.eclemma.org/jacoco">Jacoco</a> and <a href="http://www.sonarqube.org/">SonarQube</a> plugins out of the box.<br/>This is how you can leverage these plugins : </p>
<ul>
  <li><code>jerkar jacoco#</code> : does <code>doDefault</code> but unit tests will be instrumented by Jacoco code coverage tool</li>
  <li><code>jerkar jacoco# -jacoco#produceHtml</code> : same but also set the <code>JkBuildPluginJacoco#produceHtml</code> field to <code>true</code>. It leads in producing an html report along the standard jacoco.exec binary report</li>
  <li><p><code>jerkar doDefault sonar#verify</code> : does the default + execute the <code>verify</code> method located in the sonar plugin (launch a sonar analysis)<br/>Analysis is launched on a local SonarQube server unless you specify specific Sonar settings. Sonar will leverage of jacoco report</p></li>
  <li><code>jerkar doDefault verify sonar# jacoco#</code> : launches the <code>doDefault</code> and <code>verify</code> methods and activates the jacoco and sonar plugins. Sonar plugin hooks the <code>JkBuild verify</code> method by launching a SonarQube analysis</li>
</ul><h2>Build API</h2><p>Jerkar framework comes with a fluent style API making a joy to perform all kind of thing generally encountered in build domain.<br/>Almost all classes coming from this API are <strong>immutable</strong> providing a high degree of robustness and reusability.</p><p>The follow will give you some ideas of what you can accomplish with this API. To have more insight, please visit <a href="http://jerkar.github.io/javadoc/latest/index.html">Javadoc</a>.</p><h3>File manipulation &amp; selection</h3><p>The <code>JkFileTree</code> class allow to define a set of files having a common root folder and to performs numerous operation on.<br/>The following code, show how to construct a <em>war</em> file from dispersed elements.</p>
<pre><code>JkFileTree war = JkFileTree.of(warDir).importDirContent(webappContentDir)
	.from(&quot;WEB-INF/classes&quot;).importDirContent(build.classDir())
	.from(&quot;../lib&quot;).importFiles(JkFileTree.of(libDir).include(&quot;**/*.jar&quot;);
war.zip().to(warFileDest);
</code></pre><p><code>from</code> method returns another <code>JkFileTree</code> but rooted at the specified relative path.<br/><code>importXxx</code> method copies specified element at the root of the file tree.</p><p><code>JkFileTreeSet</code>, <code>JkPath</code> (sequence of files), <code>JkZipper</code>, <code>JkFileFilter</code> and <code>JkUtilsFile</code> are the other players for manipulate files.<br/>All belong to <code>org.jerkar.api.file</code> package.</p><h3>Process launching</h3><p>The <code>JkProcess</code> class provides super easy way to launch external process.<br/>The follow show how to launch a Maven process on the project located at <strong>projectBaseDir</strong>.</p>
<pre><code>JkProcess.of(&quot;mvn&quot;, &quot;clean&quot;,&quot;install&quot;,&quot;-U&quot;)
    .andParameters(JkOptions.isVerbose(), &quot;-X&quot;)
    .withWorkingDir(projectBaseDir)
    .failOnError(true)
    .runSync();
</code></pre><h3>Java core stuffs</h3><h4>Classpaths</h4><p><code>JkClasspath</code> allows to construct class-paths and perform queries or get string representations.<br/>For example, the follow creates a classpath taking in account all jar under the <strong>extraLibs</strong> folder,<br/>then returns the first one containing the <code>my.SearchedClass</code> class.</p>
<pre><code>File jar = JkClasspath.of(lib1, lb2, lib3).getEntryContainingClass(&quot;my.SearchedClass&quot;); 
</code></pre><h4>Class loarders</h4><p><code>JkClassloader</code> allows to get or construct class-loaders then scan the class-path or invoke methods within. </p><p>For example, the follow get the current class loader and loads every class having a package starting by <code>com.mypack</code></p>
<pre><code>JkClassLoader.current().loadClasses(&quot;com/mypack/**/*&quot;);
</code></pre><p>This class provides also methods to perform cross class-loader calls friendly.</p><h4>Lauching Java programs</h4><p><code>JkJavaProcess</code> is a Java specific flavor of <code>JkProcess</code>. </p>
<pre><code>JkJavaProcess.of().withWorkingDir(myWorkingDir)
    .andClasspath(mtClasspath).runJarSync(myJarFile);
</code></pre><h3>Java build API</h3><p>Jerkar provides Fluent API for addressing build of Java projects.</p><h4>Compile Java</h4><p>The <code>JkJavaComiler</code> class allows to compile Java sources.</p>
<pre><code>JkJavaCompiler.ofOutput(classDir).withClasspath(classpath).andSourceDir(src).compile();
</code></pre><h4>Junit</h4><p>The <code>JkUnit</code> class allow to run Junit tests with flexible settings.</p>
<pre><code>JkUnit.ofFork(classpath.and(jarFile))
    .withClassesToTest(JkFileTree.of(classDir).include(&quot;**/*Test.class&quot;))
    .withReportDir(reportDir)
    .withReport(JunitReportDetail.FULL)
    .forked(true)
    .run();
</code></pre><p>You can also enhance the Junit process for performing Jacoco test coverage :</p>
<pre><code>JkUnit.ofFork(classpath.and(jarFile))
    .withClassesToTest(JkFileTree.of(classDir).include(&quot;**/*Test.class&quot;))
    .withReportDir(reportDir)
    .withEnhancer(JkocoJunitEnhancer.of(reportDir))
    .run();
</code></pre><p>This will launch Junit with Jacoco Agent and produce the coverage report in the <strong>reportDir</strong>.</p><h3>Dependency Management</h3><p>For resolving dependencies you will mainly deal with following classes <code>JkScope</code>, <code>JkRepo</code>, <code>JkRepos</code>,<br/><code>JkDependencies</code>, <code>JkModuleId</code>, <code>JkDependencyResolver</code> </p>
<pre><code>// Define the main module
JkVersionedModule versionedModule = JkModuleId.of(&quot;myGroup&quot;,&quot;myName&quot;).version(&quot;1.2&quot;);

// Create a repo for getting artifacts
JkRepos repos = JkRepos.maven(&quot;http://my.main.repo&quot;);

// Define dependencies
JkDependencies dependencies = JkDependencies.builder()
	.on(GUAVA, &quot;18.0&quot;).scope(JkJavaBuild.COMPILE)
	.on(JUNIT, &quot;4.11&quot;).scope(JKJavaBuild.TEST)
	.build();

// Resolve and get the dependencies as file sequence
Iterable&lt;File&gt; depFiles = JkDependencyrResolver.managed(repos, dependencies, versionedModule)
	.get(JKJavaBuild.TEST);

</code></pre><h3>Publication</h3><h3>Cryptography</h3><p>You can sign files or check signature with PGP using the <code>JkPgp</code> class. </p>
<pre><code>JkPgp pgp = JkPgp.ofSecretRing(publicRingKeyFile, privateRingKeyFile, secret);
Files signatures[] = pgp.sign(myFileToSign1, myFileToSign2); 
boolean signatureOk = pgp.verify(signedFile, signatureFile);
</code></pre><p>Note that you don't need to have PGP installed. This is achieved by using <strong>bouncy Castle</strong> under the hood.</p><h3>SonarQube</h3><p>You can run SonarQube analysis using the <code>JkSonar</code>class :</p>
<pre><code>JkSonar.of(projectKey, projectName, projectVersion)
    .withProjectBaseDir(baseDir) 
    .withBinaries(binDir)
    .withLibraries(libs)
    .withSources(sourceDirs)
    .withProperty(JkSonar.JUNIT_REPORTS_PATH, junitReportDir)
    .withProperty(JkSonar.JACOCO_REPORTS_PATH, jacocoexecReportFile)
    .run();
</code></pre>
	</p>

	<hr />

		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2014 | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.3.2</a></p>
      </div>
    </div>
    
   
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="js/jquery-1.11.1.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/prettify.js"></script>
 	<script>
 	    lastSelect = null;
    	$('.liexpandable').click(function(evt) {
    		var li = $(evt.target).parents("li").first();
    		var ul = li.find(".sub-menu").first();
    		console.log(ul.is(':visible'));
    		evt.stopPropagation();
    		if (ul.is(':visible') && li.html() !== lastSelect) {
    			lastSelect = li.html();
    			return;
    		}
    		lastSelect = li.html();
      		ul.toggle();
 		});
    </script>
    
  </body>
</html>