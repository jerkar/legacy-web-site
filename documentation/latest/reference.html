<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>reference</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Java build tool">
    <meta name="author" content="Jerome Angibaud">
    <meta name="keywords" content="build,java,tool,automation,maven,ant,gradle,buildr,sbt,make,compiler,tester,jacoco">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../css/bootstrap.css" rel="stylesheet">
    <!-- <link href="../../css/bootstrap.min.css" rel="stylesheet">  -->
    <link href="../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link href="../../css/prettify.css" rel="stylesheet">
    <link href="../../css/jerkar.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
      
    <![endif]-->
    
      <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../../favicon.ico">
  
  	<!-- highlight.js -->
  	<script src="../../js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<link rel="stylesheet" href="../../css/highlight-idea.css">
	
	<!-- sidebar css -->
	<link href="../../css/sidebar.css" rel="stylesheet">
  
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand">
          	<img style="max-width:32px;margin-top: -7px;" src="../../img/logo.png">
          </a>
          <a class="navbar-brand">Jerkar</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../../index.html">Home</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation<b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="../../documentation/latest/tutorial.html">Tutorial</a></li>
                <li><a href="../../documentation/latest/reference.html">Reference Guide</a></li>
                <li><a href="../../javadoc/latest/index.html">Javadoc</a></li>
              </ul>
            </li>
            <li><a href="../../about.html">About</a></li>
          </ul>
        </div>
       
        
      </div>
    </div>
    <div class="container">
	<p>
	<div id="sidebar-menu" class="col-md-3 hidden-xs hidden-sm">
    <ul class="main-menu nav nav-stacked affix">
        <li><a href="javascript:jerkarMoveTo('Introduction',2);">Introduction</a></li>
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Jerkar runtime',2);">Jerkar runtime</a>
          <ul class="sub-menu">
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Launching Java Process',3);">Launching Java Process</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Embedded mode',4);">Embedded mode</a></li>
              </ul>
            </li>
            <li><a href="javascript:jerkarMoveTo('Jerkar execution',3);">Jerkar execution</a></li>
          </ul>
        </li>
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Build Configuration',2);">Build Configuration</a>
          <ul class="sub-menu">
            <li><a href="javascript:jerkarMoveTo('Environment variables',3);">Environment variables</a></li>
            <li><a href="javascript:jerkarMoveTo('System properties',3);">System properties</a></li>
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Jerkar options',3);">Jerkar options</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Injecting options',4);">Injecting options</a></li>
                <li><a href="javascript:jerkarMoveTo('Retrieve Jerkar options',4);">Retrieve Jerkar options</a></li>
                <li><a href="javascript:jerkarMoveTo('Composite options',4);">Composite options</a></li>
                <li><a href="javascript:jerkarMoveTo('Standard options',4);">Standard options</a></li>
                <li><a href="javascript:jerkarMoveTo('How to document options ?',4);">How to document options ?</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Dependency Management',2);">Dependency Management</a>
          <ul class="sub-menu">
            <li><a href="javascript:jerkarMoveTo('What is a dependency ?',3);">What is a dependency ?</a></li>
            <li><a href="javascript:jerkarMoveTo('What is a scope ?',3);">What is a scope ?</a></li>
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Define dependencies for a project',3);">Define dependencies for a project</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Define scopes',4);">Define scopes</a></li>
                <li class="liexpandable"><a href="javascript:jerkarMoveTo('Defining individual dependency',4);">Defining individual dependency</a>
                  <ul class="sub-menu">
                    <li><a href="javascript:jerkarMoveTo('Dependency on arbitrary files',5);">Dependency on arbitrary files</a></li>
                    <li><a href="javascript:jerkarMoveTo('Dependency on files produced by computation',5);">Dependency on files produced b...</a></li>
                    <li><a href="javascript:jerkarMoveTo('Dependency on module',5);">Dependency on module</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="javascript:jerkarMoveTo('Bind dependencies to scope',3);">Bind dependencies to scope</a></li>
          </ul>
        </li>
    </ul>
</div>
<script>
function jerkarMoveTo(title, level) {
    var elemType = 'h'+level;
    var elems = $(elemType);
    var elem;
    for (var i = 0; i < elems.length; i++) {
    	var candidate = elems[i];
    	if (candidate.outerText ===  title) {
    		elem = candidate;
    		break;
    	}
    }
    $('html, body').animate({
        scrollTop: $(elem).offset().top -50
    }, 200);
}
</script><p><div id="static-content" class="col-md-9"></p><h2>Introduction</h2>
<hr/><p>This document stands for reference guide. You'll find here details on Jerkar behaviour. </p>
<ul>
  <li><p>If you need an overall vision of Jerkar, please have a <a href="http://jerkar.github.io/tour.html"><strong>tour</strong></a>.</p></li>
  <li><p>If you need a a step-by-step learning guide, please visit <a href="http://jerkar.github.io/documentation/latest/getting-started.html"><strong>tutorial</strong></a>.</p></li>
  <li><p>If you need more details about the API or in-deep behavior, please consult <a href="http://jerkar.github.io/javadoc/latest/index.html"><strong>javadoc</strong></a> or browse <a href="https://github.com/jerkar/jerkar/tree/master/org.jerkar.core"><strong>source code</strong></a>. You can also raise an issue in Git-hub to request an improvement on the documentation.</p></li>
</ul><p><br/></p><h2>Jerkar runtime</h2>
<hr/><p>This section details what happens behind the cover when Jerkar is run.</p><h3>Launching Java Process</h3><p>Jerkar is a pure Java application requiring <strong>JDK 6 or above</strong>. <strong>JDK</strong> is required and <strong>JRE</strong> is not sufficient.<br/>Indeed Jerkar uses the JDK tools for compiling build definitions and generate Javadoc.</p><p>For an easy launching of the java process in command line, Jerkar provides native scripts ( <em>jerkar.bat</em> for <strong>Windows</strong> and <em>jerkar</em> for <strong>Unix</strong> ).<br/>These scripts do the following :</p>
<ol>
  <li><strong>Find the java executable path</strong> : If a <code>JAVA_HOME</code> environment variable is defined then it takes this value as <code>java</code> path. Otherwise it takes the <code>java</code> executable defined in the <em>PATH</em> environment variable if any.</li>
  <li><strong>Get java execution option</strong> : If an environment variable <code>JERKAR_OPTS</code> exists then its value will be passed in the <code>java</code>command line parameters, otherwise default <code>-Xmx512m -XX:MaxPermSize=512m</code> is passed.</li>
  <li><strong>Set Jerkar classpath</strong> in the following order :
  <ul>
    <li>all jar and zip files found under <em>[WORKING DIR]/build/libs/build</em></li>
    <li>all jar and zip files found under <em>[JERKAR HOME]/libs/ext</em></li>
    <li>the <em>[JERKAR_HOME]/org.jerkar.core.jar</em> file</li>
  </ul></li>
  <li><strong>Run the <code>org.jerkar.tool.Main</code> class</strong> passing the command line argument as is. So if you have typed <code>jerkar myArg1 myArg2</code> the <code>myArg1 myArg2</code> will be passed as Java command-line arguments.</li>
</ol><h4>Embedded mode</h4><p>Note that <strong><em>[JERKAR_HOME]/org.jerkar.core.jar</em></strong> comes after <strong><em>[WORKING_DIR]/build/libs/build/*</em></strong> in the classpath.<br/>This means that if a version of Jerkar (org.jerkar.core-fat.jar) is in this directory, then the build will be processed with this instance of Jerkar and not with the one located in in <em>[JERKAR HOME]</em>.</p><p>This is called the <strong>Embedded</strong> mode. It guarantees that your project will build regardless of the Jerkar version installed on the host machine.<br/>This mode allows to build your project even if Jerkar is not installed on the host machine. just execute <code>java -cp build/libs/build/* org.jerkar.tool.Main</code> instead of <code>jerkar</code>.</p><h3>Jerkar execution</h3><p>The <code>org.jerkar.tool.Main#main</code> is the entry point of Jerkar. It's the method you invoke to launch/debug a Jerkar build within your IDE.</p><p>It processes as follow :</p>
<ol>
  <li>Parse the command line.</li>
  <li>Populate the system properties and Jerkar options from configuration files and command line (see <strong>build configuration</strong>).</li>
  <li>Pre-process Java source files located under <em>[WORKING DIR]/build/def</em> directory if any. The preprocessor parses source code to extract content of <code>@JkImport</code> and <code>@JkProject</code> Java annotations.<br/>The <code>@JkImport</code> contains the binary dependencies on modules hosted in Maven/Ivy repository (as <code>@JkImport(&quot;commons-httpclient:commons-httpclient:3.1&quot;)</code> while the <code>@JkProject</code> contains dependency on build definition classes of an other project (as <code>@JkProject(&quot;../org.jerkar.plugins-jacoco&quot;)</code>).<br/>If the project build definition sources contain some <code>@JkProject</code> annotations, the dependee project are pre-processed and compiled recursively prior to go next.</li>
  <li>Compile Java source files located under <em>[WORKING DIR]/build/def</em> directory. The compilation is done using classpath constituted in the prevous step.</li>
  <li>Instantiate the build class. The build class is the class specified by the <code>buildClass</code> option if present. If not, it is the first class implementing <code>org.jerkar.tool.JkBuild</code>. If no class implementing <code>org.jerkar.tool.JkBuild</code> is found then the <code>org.jerkar.tool.builtins.javabuild.JkJavaBuild</code> is instantiated.<br/>The class scanning processes classes in alphabetic order then subpackage in deep first. This mean that class <code>MyBuid</code> will be scanned prior <code>apackage.ABuild</code>, and <code>aa.bb.MyClass</code> will be scanned prior <code>ab.OtherClass</code>.<br/>The <code>buildClass</code> option can mention a simple name class (class name omitting its package). If no class matches the specified <code>buildClass</code> then an exception is thrown.</li>
  <li>Inject options in build instance fields (see <strong>build configuration</strong>).</li>
  <li>Call the <code>init()</code> method on the build instance.</li>
  <li>Instantiate and bind plugins.</li>
  <li>Invoke methods specified in arguments.</li>
</ol><p><br/></p><h2>Build Configuration</h2>
<hr/><p>Jerkar build are configurable. Build definition classes can retrieve values defined at runtime by reading :</p>
<ul>
  <li>an environment variable</li>
  <li>a system property</li>
  <li>a Jerkar option</li>
</ul><h3>Environment variables</h3><p>There is nothing specific to Jerkar. Just set the environment variable as you usually do on your OS and get the value from build using the standard Java <code>System#getenv</code> method.</p><h3>System properties</h3><p>Naturally, your build definitions can read system properties by using the standard method <code>System#getProperty</code>.</p><p>Jerkar proposes 3 ways to inject system properties :</p>
<ul>
  <li>By editing <strong><em>[Jerkar Home]/system.properties</em></strong> file.<br/> Note that if you are running Jerkar in embedded mode, the <strong><em>[Jerkar Home]/system.properties</em></strong> file will not be taken in account but <strong><em>[project dir]/build/def/build/system.properties</em></strong>.</li>
  <li>By editing <strong><em>[Jerkar User Home]/system.properties</em></strong> file.</li>
  <li>By mentioning the property/value in Jerkar <strong>command line</strong> as <code>Jerkar doDefault -DmyProperty=myValue</code>.</li>
</ul><p>The <strong>command line</strong> takes precedence on <strong><em>[Jerkar User Home]/system.properties</em></strong> that in turn, takes precedence on <strong><em>[Jerkar Home]/system.properties</em></strong>.</p><p>In every case, defined system properties are injected after the creation of the java process (via <code>System#setProperty</code> method).</p><h3>Jerkar options</h3><p>Jerkar options are similar to system properties as it stands for a set of <strong>key/value</strong>. You can read it by using a dedicated API or let it be injected in Java field as explained below.</p><h4>Injecting options</h4><p>Jerkar proposes 3 ways to inject options :</p>
<ul>
  <li>By editing <strong><em>[Jerkar Home]/options.properties</em></strong> file.<br/> Note that if you are running Jerkar in embedded mode, the <strong><em>[Jerkar Home]/options.properties</em></strong> file will not be taken in account but <strong><em>[project dir]/build/def/build/options.properties</em></strong>.</li>
  <li>By editing <strong><em>[Jerkar User Home]/options.properties</em></strong> file.</li>
  <li>By mentioning the property/value in the Jerkar command line as <code>Jerkar doDefault -myOption=myValue</code>.</li>
</ul><p>As for system properties, The <strong>command line</strong> takes precedence on <strong><em>[Jerkar User Home]/options.properties</em></strong> that takes in turn, precedence on <strong><em>[Jerkar Home]/options.properties</em></strong>.</p><p>Note for boolean, when no value is specified, <code>true</code> will be used as default.</p><h4>Retrieve Jerkar options</h4><p>You can retrieve string values using the <code>JkOptions</code> API providing convenient static methods as <code>JkOptions#get</code>, <code>JkOptions#getAll</code> or <code>JkOptions#getAllStartingWith(String prefix)</code>.</p><p>You can also retrieve options just by <strong>declaring fields in build definition class</strong>.<br/>All non private instance fields of the build definition class, are likely to be injected as an option.</p><p>For example, if you declare a field like <code>protected int size = 3;</code> then you can override the default value by injecting the option value with any of the 3 ways described above.</p><p>Any fields <strong>except static fields or private fields</strong> can be used to inject options.<br/>If you want <strong>inject option in a private field</strong>, you must annotate it with <code>@JkDoc</code> as <code>@JkDoc private boolean myField;</code> </p><p>Note that the injected string value will be automatically converted to the target type.<br/>Handled types are <strong>String</strong>, <strong>all primitive types (and their wrappers)</strong>, <strong>enum</strong>, <strong>File</strong> and <strong>composite object</strong>.<br/>To get a precise idea on how types are converted see <a href="https://github.com/jerkar/jerkar/blob/master/org.jerkar.core/src/main/java/org/jerkar/tool/OptionInjector.java">this code</a>.</p><h4>Composite options</h4><p>Composite options are a way to structure your options. Say that you want to configure some server access with url, userName and passwsord,<br/>you can gather all these information in a object as </p>
<pre><code class="Java">class Server {
    private String url;
    private String userName;
    private String password;
    // ...
}
</code></pre><p>declare a Server field in your build :</p>
<pre><code class="Java">class MyBuild extends JkBuild {
   Server deployServer;
   ...
}
</code></pre><p>Then you can inject the server object using following options :</p>
<pre><code>deployServer.url=http:/myServer:8090/to
deployServer.username=myUsername
deployServer.password=myPassword
</code></pre><h4>Standard options</h4><p>Jerkar predefines some standard options that you can set for any build :</p>
<ul>
  <li>buildClass : This forces the build class to use. If this option is not null then Jerkar will used the specified class as the build class.<br/>Note that this can be a simple class as <code>MyBuildClass</code> is enough for running <code>org.my.project.MyBuildClass</code>.</li>
  <li>verbose : when <code>true</code> Jerkar will be more verbose at logging at the price of being slower and bloating logs. Default value is <code>false</code>.</li>
  <li>silent : when <code>true</code>nothing will be logged. Default is <code>false</code></li>
</ul><h4>How to document options ?</h4><p>If you want your option been displayed when invoking <code>jerkar help</code> you need to annotate it with <code>@JkDoc</code>.</p><p>For example :</p>
<pre><code>@JkDoc(&quot;Make the test run in a forked process&quot;)
private boolean forkTests = false;
</code></pre><p><br/></p><h2>Dependency Management</h2>
<hr/><h3>What is a dependency ?</h3><p>In this context, we call a <strong>dependency</strong> an indication that can be resolved to a file (or a set of file) needed to accomplish certain part of the build.<br/>So for example if a project <em>Foo</em> has a <strong>dependency</strong> <em>bar</em>, this means that <em>Foo</em> may need the files indicated by <em>bar</em> for building.<br/>In Jerkar code, the dependency concept is embodied by the abstract <code>JkDependency</code> class.</p><p>Jerkar distinguishes 3 types of <strong>dependency</strong> :</p>
<ul>
  <li><strong>Arbitrary files</strong> located on the file system (Embodied by <code>JkFileSystemDependency</code> class). These files are assumed to be present on the file system when the build is running.</li>
  <li><strong>Files produced by a computation</strong> (Embodied by <code>JkComputedDependency</code> class). These files may be present on file system or not. If they are not present, the computation is run in order to produce the missing files. Generally the computation stands for the build of an external project.</li>
  <li><strong>Reference to module</strong> (Embodied by <code>JkModuleDependency</code>) hosted in a binary repository (Ivy or Maven for instance) : Jerkar can consume and resolve transitively any artifact located in a repository as you would do with Maven or Ivy.</li>
</ul>
<p class="alert alert-success">
For the last, Jerkar is using <b>Ivy 2.4.0</b> under the hood. The library is embedded in the Jerkar jar and is executed in a dedicated classloader. So all happens as if there where no dependency on Ivy.
</p><h3>What is a scope ?</h3><p>Projects may need dependencies to accomplish certain tasks and needed dependencies may vary according the executed tasks.<br/>For example, to <strong>compile</strong> you may need <em>guava</em> library only but to <strong>test</strong> you'll need <em>junit</em> library as well.<br/>To segregate dependencies according their usage, Jerkar uses the notion of <strong>scope</strong> (embodied by <code>JkScope</code> class). This notion is similar to the Maven scope.</p><p>Scopes can <strong>inherit</strong> from each other. This means that if a scope <em>Foo</em> inherits from scope <em>Bar</em> then a dependencies declared with scope <em>Bar</em> will be also considered as declared with scope <em>Foo</em>.<br/>For instance, in <code>JkJavaBuild</code>, scope <code>TEST</code> inherits from <code>RUNTIME</code> that inherits from <code>COMPILE</code> so every dependencies declared with scope <code>COMPILE</code> are considered to be declared with scope <code>RUNTIME</code> and <code>TEST</code> as well. </p><p>By default, scopes are <strong>transitive</strong>. This has only a meaning for <strong>reference to module</strong>.<br/>If we have 3 modules having the following dependency scheme : <code>A</code> -&gt; <code>B</code> -&gt; <code>C</code> and the <code>A</code>-&gt; <code>B</code> dependency is declared with a <strong>non transitive scope</strong>, then <code>A</code> won't depend from <code>C</code>. </p><p>Projects consuming artifacts coming from Ivy repository can also use <code>JkScopeMapping</code> which is more powerfull. This notion maps strictly to the <a href="http://ant.apache.org/ivy/history/2.2.0/ivyfile/configurations.html">Ivy configuration</a> concept.</p><h3>Define dependencies for a project</h3><p>To define dependencies of a project, you basically define a list of <strong>scoped dependency</strong> (embodied by <code>JkScopedDependency</code>).<br/>A <strong>scoped dependency</strong> is a <strong>dependency</strong> associated with one or several <strong>scopes</strong>.</p><p>So practically, you define some scopes then you bind dependencies to these scopes.</p>
<pre><code class="Java">return JkDependencies.builder()
    .on(GUAVA, &quot;18.0&quot;).scope(COMPILE)  
    .on(JERSEY_SERVER, &quot;1.19&quot;).scope(COMPILE)
    .on(&quot;com.orientechnologies:orientdb-client:2.0.8&quot;).scope(COMPILE)
    .on(JUNIT, &quot;4.11&quot;).scope(TEST)
    .on(MOCKITO_ALL, &quot;1.9.5&quot;).scope(TEST, ANOTHER_SCOPE)
.build();
</code></pre><p>You can also omit the scope and set it later...</p>
<pre><code class="Java">JkDependencies deps = JkDependencies.builder()
    .on(GUAVA, &quot;18.0&quot;)
    .on(JERSEY_SERVER, &quot;1.19&quot;)
    .on(&quot;com.orientechnologies:orientdb-client:2.0.8&quot;)
    .on(JUNIT, &quot;4.11&quot;).scope(TEST)
    .on(MOCKITO_ALL, &quot;1.9.5&quot;).scope(TEST, ANOTHER_SCOPE)
.build();
...
deps = deps.withDefaultScope(COMPILE);
</code></pre><p>Look at the <a href="http://jerkar.github.io/javadoc/latest/org/jerkar/api/depmanagement/JkDependencies.html">JkDepencies class API</a> to get see all possibilities.</p><h4>Define scopes</h4><p>In the examples above, we use the predefined scopes <code>COMPILE</code> or <code>TEST</code>. These scopes are standard scopes defined on the <a href="https://github.com/jerkar/jerkar/blob/master/org.jerkar.core/src/main/java/org/jerkar/tool/builtins/javabuild/JkJavaBuild.java">JkJavaBuild class</a>.<br/>So if your build definition class inherit from <code>JkJavaBuild</code> template you won't need to create it. </p><p>If you need to create your own <em>scope</em>, a good practice is to declare it as java constant (<code>static final</code>) as it will be reusable anywhere all over your build definition.</p><p>As an example, these are the scopes declared in <code>JkJavaBuild</code> :</p>
<pre><code class="Java">public static final JkScope PROVIDED = JkScope.of(&quot;provided&quot;).transitive(false)
    .descr(&quot;Dependencies to compile the project but that should not be embedded in produced artifacts.&quot;);

public static final JkScope COMPILE = JkScope.of(&quot;compile&quot;)
    .descr(&quot;Dependencies to compile the project.&quot;);

public static final JkScope RUNTIME = JkScope.of(&quot;runtime&quot;).extending(COMPILE)
	.descr(&quot;Dependencies to embed in produced artifacts (as war or fat jar files).&quot;);

public static final JkScope TEST = JkScope.of(&quot;test&quot;).extending(RUNTIME, PROVIDED)
	.descr(&quot;Dependencies necessary to compile and run tests.&quot;); 
</code></pre><h4>Defining individual dependency</h4><p>Now get focus on each type of dependency we can declare.</p><h5>Dependency on arbitrary files</h5><p>You just have to mention the path of a file. If the file does not exist at resolution time (when the dependency is actually retrieved) the build fails.<br/>You can declare many files for one dependency.</p>
<pre><code>    final File depFile1 = new File(&quot;/my/file1.jar&quot;);
	
    final File depFile2 = new File(&quot;/my/file2.zip&quot;);

    @Override
    protected JkDependencies dependencies() {
        return JkDependencies.builder()
            .on(depFile1, depFile2).build();
    }
		
</code></pre><h5>Dependency on files produced by computation</h5><p>It is typically used for <strong>multi projects builds</strong> or <strong>multi module</strong> projects.</p><p>The principle is that if the specified files are not found, then the computation is run in order to generate the missing files.<br/>If some files still missing after the computation run, the build fails (an exception is thrown).</p><p>This mechanism is quite simple yet powerfull as it allows to adress following use case :</p>
<ul>
  <li>Dependency on files produced by other Jerkar project</li>
  <li>Dependency on files produced by external project built with any type of techno (Ant, Grunt, Maven, Gradle, SBT, Android SDK, Make, ...)</li>
  <li>Dependency on files produced by a method of the main build.</li>
</ul><p>The generic way is to construct this kind of dependency using a <code>java.lang.Runnable</code>.</p>
<pre><code>private Runnable computation = new Runnable() {...}; 
	
File fooFile = new File(&quot;../otherproject/target/outpufoo.jar&quot;);  // dependency file  
	
@Override
protected JkDependencies dependencies() {
return JkDependencies.builder()
    .on(JkComputedDependency.of(computation, fooFile)).build();
}
</code></pre><p>Here, if the <em>fooFile</em> is absent then the <strong>computation</strong> will be run prior to retry to find <em>FooFile</em>.</p><p>Jerkar provides some shortcuts to deal with other Jerkar projects : For this, you can create the dependency directly from the dependee build instance. </p>
<pre><code>@JkProject(&quot;../foo&quot;)          // The external project path relative to the current project root
public JkJavaBuild fooBuild;  // This is the build coming from the &#39;foo&#39; project 
	
@Override
protected JkDependencies dependencies() {
    return JkDependencies.builder()
	    .on(fooBuild.asComputedDependency(&quot;doPack&quot;, fooBuid.packer().jarFile() ))
    .build();
}
</code></pre><p>Here the method <code>doPack</code> of <code>fooBuild</code> will be invoked if the specified file does not exist.<br/>See <em>Multi Module Project</em> to get details how parameters are propagated to dependee builds.</p><p>You can also use another kind of project mentioning the command line to run in order to build the project.</p>
<pre><code>File fooDir = new File(&quot;../../foo&quot;);  // base dir of a Ant project 
File fooJar = new File(fooDir, &quot;build/foo.jar&quot;);
JkProcess antBuild = JkProcess.of(&quot;ant&quot;, &quot;makeJar&quot;).withWorkingDir(fooDir));
...
@Override
protected JkDependencies dependencies() {
    return JkDependencies.builder()
        .on(JkProjectDependency.of(antBuild, fooJar))).scope(PROVIDED)  
    .build();
}
</code></pre><p>Here, if <em>fooJar</em> file does not exist the <code>ant makeJar</code> command line will be invoked prior to retry to find the file.<br/>If the file still does not exist then the build fails.</p><h5>Dependency on module</h5><p>This is for declaring a dependency on module hosted in <em>Maven</em> or <em>Ivy</em> repository.</p><h3>Bind dependencies to scope</h3><p>The whole project dependency description lie in a single instance of <code>JkDependencies</code>. This class offers convenient factory methods and builder to define the dependencies.</p><p>```</p><p>```</p><p><br/></p><p></div> <!--end of wrapper div --> </p>
	</p>

	<hr />

		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2014 | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.3.2</a></p>
      </div>
    </div>
    
   
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../js/jquery-1.11.1.min.js"></script>
    <script src="../../js/bootstrap.min.js"></script>
    <script src="../../js/prettify.js"></script>
 	<script>
 	    lastSelect = null;
    	$('.liexpandable').click(function(evt) {
    		var li = $(evt.target).parents("li").first();
    		var ul = li.find(".sub-menu").first();
    		console.log(ul.is(':visible'));
    		evt.stopPropagation();
    		if (ul.is(':visible') && li.html() !== lastSelect) {
    			lastSelect = li.html();
    			return;
    		}
    		lastSelect = li.html();
      		ul.toggle();
 		});
    </script>
    
  </body>
</html>